# a script that generates necessary setups to calculate spacial derivatives of g
# ideally, this script should be used while on cluster
import sys
from getters import get_coord

# Perturbation distance in Angstrom; the same value is used for all the atoms and all the directions
perturb_distance = 0.01

# Input name to be used for all the geometries generated by this script
input_name = "system.inp"

# This script assumes the following directory tree which must be present:
# /dirs/1/ ; /dirs/2/ ... /dirs/"n=number_of_atoms"/
#   /dirs/1/x/ ; /dirs/1/y/ ; /dirs/1/z/ ; /dirs/2/x/ ...
#       /dirs/1/x/plus/ ; /dirs/1/x/minus/ ; /dirs/1/y/plus/ ...
path_to_folder = "./dg_so/dirs"  # the folder where atom directories ("1", "2", "plus" etc.) are located
path = './epr_orca/so/system.inp'  # path to the original unperturbed optimized geometry input file

with open(path, "r") as f:
    orca_input = f.read().splitlines()


# Changes a coord_component of an atom #atom_number by a specified distance in plus or minus direction
# given a coord_block.
# Note that the lowest atom_number is 1
def shift_atom(coord_block, atom_number, coord_component, direction, distance):
    # ORCA coordinates block has the following format:
    # atom_type   x_coord   y_coord  z_coord
    # That's why e.g. x_coord has index "1" while "0" corresponds to atom_type
    match coord_component:
        case "x":
            index = 1
        case "y":
            index = 2
        case "z":
            index = 3
        case _:
            print("Something's wrong with the format")
            sys.exit()

    match direction:
        case "plus":
            delta = abs(distance)
        case "minus":
            delta = -1*abs(distance)
        case _:
            print("must be either plus or minus")
            sys.exit()

    # get the line from coord_block that corresponds to atom_number; split the line afterwards;
    # note: atom_number starts with 1 while python indexing starts with 0, hence "- 1" in the expression
    line_components = coord_block[atom_number - 1].split()

    # get the chosen coord_component from the line, convert to float;
    component_to_change = float(line_components[index])

    # change the coordinate
    updated_component = component_to_change + delta

    # convert back to string type with 6 decimals; update the line from coord_block with a new coordinate
    line_components[index] = str("{:0.6f}").format(updated_component)

    # Update the coord block; add some spaces to make it look (supposedly) better.
    # NOTE!!!: must assign a slice of a list to a variable,
    # i.e. using [:], in order to actually create a different object.
    new_coord_block = coord_block[:]
    new_coord_block[atom_number - 1] = "  " + "    ".join(line_components)

    return new_coord_block


def main():

    # get the information from the original input file
    initial_coord, st, en = get_coord(orca_input)

    # store the rest of the input; will be the same for all other input files /w perturbed geometries
    top = orca_input[0:st+1]
    bot = orca_input[en:]

    # generate perturbed geometries
    for i in range(len(initial_coord)):
        for j in ["x", "y", "z"]:
            for k in ["plus", "minus"]:
                perturbed_coord = shift_atom(initial_coord, i + 1, j, k, perturb_distance)
                modified_input = top + perturbed_coord + bot
                to_write = "\n".join(modified_input)
                path_tmp = path_to_folder + "/" + str(i + 1) + "/" + j + "/" + k
                with open(path_tmp + "/" + input_name, "w") as f:
                    f.write(to_write)


if __name__ == "__main__":
    main()
